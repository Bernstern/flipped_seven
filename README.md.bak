# Flip 7 Tournament Harness

A strongly-typed, event-sourced Python implementation of Flip 7 with tournament support and bot development framework.

## Overview

Flip 7 is a card game where players draw numbered cards (0-12), modifiers (X2, +2/+4/+6/+8/+10), and action cards (Freeze, Flip Three, Second Chance) trying to reach exactly 7 unique number cards for bonus points without busting (drawing duplicates). First player to 200 points wins.

**Key Features:**
- Full type hints (mypy strict mode compliant)
- Event sourcing (complete game replay from JSONL logs)
- Tournament system (round-robin, parallel execution)
- Bot interface (Protocol-based with timeout enforcement)
- Immutable state (frozen dataclasses throughout)
- Human player mode (play against bots or debug)

## Installation

```bash
cd flipped_seven
uv sync --all-extras
```

## Quick Start

### Play Against Bots (Human Mode)

```bash
uv run flip7 quick-game -p 2 -b human -b conservative
```

This lets you play interactively against a bot, seeing full game context at each decision point.

### Watch Bots Play

```bash
uv run flip7 quick-game -p 2 -b random -b conservative
```

### Run a Tournament

```bash
uv run flip7 run-tournament examples/sample_tournament_config.py
```

## Creating Your Own Bot

### 1. Create Your Bot Class

Create a new file `my_bot.py`:

```python
from flip7.bots.base import BaseBot
from flip7.types.events import BotDecisionContext
from flip7.types.cards import ActionType, NumberCard
from typing import Literal


class MyBot(BaseBot):
    """My custom strategy bot."""

    def decide_hit_or_pass(self, context: BotDecisionContext) -> Literal["hit", "pass"]:
        """Decide whether to draw another card or lock in score.

        Available context:
        - context.my_tableau: Your cards and status
        - context.opponent_tableaus: All opponents' cards
        - context.deck_remaining: Cards left in deck
        - context.my_current_score: Your cumulative score
        - context.opponent_scores: Opponents' cumulative scores
        - context.current_round: Which round number
        - context.target_score: Score needed to win (usually 200)
        """
        # Example: Calculate current hand value
        hand_value = sum(c.value for c in context.my_tableau.number_cards)
        unique_numbers = len(set(c.value for c in context.my_tableau.number_cards))

        # Strategy: Be aggressive early, conservative late
        if context.current_round <= 5:
            # Early game: go for Flip 7 bonus
            if unique_numbers < 7:
                return "hit"
            return "pass"
        else:
            # Late game: play it safe
            threshold = 15 if context.my_current_score > 150 else 18
            return "pass" if hand_value >= threshold else "hit"

    def decide_use_second_chance(
        self, context: BotDecisionContext, duplicate: NumberCard
    ) -> bool:
        """Decide whether to use Second Chance to avoid busting.

        Return True to discard the duplicate and end turn (scoring normally).
        Return False to bust and score 0 this round.
        """
        # Always avoid busting
        return True

    def choose_action_target(
        self, context: BotDecisionContext,
        action: ActionType,
        eligible: list[str]
    ) -> str:
        """Choose which player to target with an action card.

        Args:
            action: FREEZE (end their turn) or FLIP_THREE (force draw 3)
            eligible: List of valid target player IDs
        """
        if action.value == "FREEZE":
            # Freeze the player with the highest score
            return max(eligible, key=lambda p: context.opponent_scores.get(p, 0))
        else:  # FLIP_THREE
            # Force the player with fewest cards to draw more
            return min(
                eligible,
                key=lambda p: len(context.opponent_tableaus[p].number_cards)
                if p in context.opponent_tableaus else 999
            )
```

### 2. Verify Bot Compliance

**IMPORTANT**: Before using your bot in tournaments, it MUST pass the compliance test suite.

Place your bot in the `flip7/bots/` directory and run:

```bash
uv run pytest tests/test_bot_compliance.py -v
```

This test suite verifies:
-  Bot implements the `Bot` protocol correctly
-  All required methods are present (`decide_hit_or_pass`, `decide_use_second_chance`, `choose_action_target`)
-  Bot returns valid decisions (`"hit"/"pass"`, `True/False`, valid player IDs)
-  Bot handles edge cases gracefully (empty hand, no opponents, near-empty deck)
-  Bot doesn't crash on any valid game state

**Your bot must pass ALL compliance tests to be tournament-ready.**

Example output:
```
tests/test_bot_compliance.py::test_bot_implements_protocol[MyBot] PASSED
tests/test_bot_compliance.py::test_decide_hit_or_pass_returns_valid_choice[MyBot] PASSED
tests/test_bot_compliance.py::test_decide_use_second_chance_returns_bool[MyBot] PASSED
tests/test_bot_compliance.py::test_choose_action_target_returns_valid_player[MyBot] PASSED
...
======================== XX passed ==========================
```

If any tests fail, fix your bot before proceeding to tournaments.

### 3. Test Your Bot Locally

Create a test script `test_my_bot.py`:

```python
from pathlib import Path
from flip7.core.game_engine import GameEngine
from flip7.bots import RandomBot, ConservativeBot
from my_bot import MyBot


def test_single_game():
    """Run a single game to test your bot."""
    player_ids = ["mybot", "random", "conservative"]
    bots = {
        "mybot": MyBot("mybot"),
        "random": RandomBot("random"),
        "conservative": ConservativeBot("conservative"),
    }

    engine = GameEngine(
        game_id="test_001",
        player_ids=player_ids,
        bots=bots,
        event_log_path=Path("./test_logs/test_001.jsonl"),
        seed=42,
    )

    final_state = engine.execute_game()

    print(f"Winner: {final_state.winner}")
    print(f"Rounds: {final_state.current_round}")
    print("Final Scores:")
    for player_id, score in final_state.scores.items():
        print(f"  {player_id}: {score}")


if __name__ == "__main__":
    test_single_game()
```

Run it:
```bash
uv run python test_my_bot.py
```

### 4. Test Against Thousands of Games

Create a tournament config `my_tournament.py`:

```python
from pathlib import Path
from flip7.tournament.config import TournamentConfig
from flip7.bots import RandomBot, ConservativeBot
from my_bot import MyBot


config = TournamentConfig(
    tournament_name="MyBot Test Tournament",
    players_per_game=3,  # 3-player games
    best_of_n=5,  # Best of 5 per matchup
    bot_classes=[MyBot, RandomBot, ConservativeBot],
    bot_timeout_seconds=5.0,
    output_dir=Path("./tournament_results"),
    save_replays=True,  # Save event logs for analysis
    max_workers=4,  # Parallel execution
    tournament_seed=42,  # For reproducibility
)
```

Run the tournament:
```bash
uv run flip7 run-tournament my_tournament.py
```

This will:
- Generate all possible 3-player matchups (C(3,3) = 1 matchup, but you can add more bots)
- Run each matchup as best-of-5
- Execute matches in parallel (4 workers)
- Save all game replays to `./tournament_results/`
- Generate statistics and leaderboard

### 5. Analyze Results

After tournament completes, check:
```
tournament_results/
├── tournament_results.json  # Complete statistics
└── replays/                 # All game event logs (if save_replays=True)
```

The JSON file contains:
```json
{
  "tournament_name": "MyBot Test Tournament",
  "total_matches": 1,
  "total_games": 5,
  "bot_statistics": {
    "MyBot": {
      "matches_played": 1,
      "matches_won": 1,
      "win_rate": 100.0,
      "games_played": 5,
      "games_won": 4,
      "total_points_scored": 1050,
      "average_points_per_game": 210.0
    },
    ...
  }
}
```

### 6. Scale Up Testing

For thorough testing, create tournaments with:

**More bots (more matchups):**
```python
bot_classes=[MyBot, MyBot2, RandomBot, ConservativeBot, AggressiveBot]
# With 5 bots and 3 players per game: C(5,3) = 10 matchups
```

**More games per matchup:**
```python
best_of_n=101  # Best of 101 = up to 51 wins needed = ~51-101 games per matchup
```

**Example: 1000+ games**
- 5 bots, 3 players per game = 10 matchups
- Best of 101 per matchup ≈ 75 games per matchup average
- Total: ~750 games
- With 8 workers: completes in minutes

## Debugging Your Bot

### Option 1: Play as Human Against Your Bot

```bash
uv run flip7 quick-game -p 2 -b human -b MyBot
```

This lets you:
- See exactly what context your bot receives
- Understand the game state at each decision point
- Test edge cases interactively

### Option 2: Replay Games

```bash
uv run flip7 replay-game tournament_results/replays/game_001.jsonl
```

Shows the complete event sequence for analysis.

### Option 3: Add Logging to Your Bot

```python
import logging

class MyBot(BaseBot):
    def __init__(self, bot_name: str):
        super().__init__(bot_name)
        self.logger = logging.getLogger(f"bot.{bot_name}")

    def decide_hit_or_pass(self, context: BotDecisionContext) -> Literal["hit", "pass"]:
        hand_value = sum(c.value for c in context.my_tableau.number_cards)
        self.logger.info(f"Hand value: {hand_value}, deciding...")

        decision = "hit" if hand_value < 15 else "pass"
        self.logger.info(f"Decision: {decision}")
        return decision
```

## CLI Commands

### `quick-game` - Run a single game
```bash
# Human vs bot
uv run flip7 quick-game -p 2 -b human -b random

# Multiple bots
uv run flip7 quick-game -p 3 -b random -b conservative -b MyBot

# Custom bot from module
uv run flip7 quick-game -p 2 -b my_bot.MyBot -b random
```

### `run-tournament` - Run a tournament
```bash
uv run flip7 run-tournament my_tournament_config.py

# With verbose output
uv run flip7 run-tournament my_tournament_config.py -v
```

### `replay-game` - Replay from event log
```bash
# Full replay
uv run flip7 replay-game results/game_001.jsonl

# Step through events
uv run flip7 replay-game results/game_001.jsonl --step

# Filter by event type
uv run flip7 replay-game results/game_001.jsonl --event-type player_hit
```

## Development

### Type Check
```bash
uvx --from mypy mypy flip7/ --strict
```

### Run Tests
```bash
uv run pytest
```

### Format Code
```bash
uvx ruff format flip7/
```

### Lint
```bash
uvx ruff check flip7/
```

## Bot Development Tips

1. **Start Simple**: Begin with basic threshold strategies before adding complexity
2. **Use Context**: All game state is available - use opponent scores and round number
3. **Test Iteratively**: Run small tournaments (best-of-3) during development
4. **Log Decisions**: Add logging to understand why your bot made choices
5. **Play Against It**: Use human mode to see your bot's behavior firsthand
6. **Analyze Replays**: Event logs show exactly what happened in each game
7. **Consider Probabilities**: With deck tracking, you can calculate bust probability
8. **Think Strategically**: Early rounds vs late rounds, ahead vs behind in score

## Game Rules

See [RULES.md](RULES.md) for complete game rules.

## Architecture

- **`flip7/constants.py`** - Immutable game rules (deck composition, scoring)
- **`flip7/types/`** - All type definitions (frozen dataclasses)
- **`flip7/core/`** - Game engine (deck, scoring, validation, round/game engines)
- **`flip7/events/`** - Event sourcing (logging, serialization, replay)
- **`flip7/bots/`** - Bot implementations (base class, examples, sandbox, human)
- **`flip7/tournament/`** - Tournament system (config, orchestration, results)
- **`flip7/utils/`** - Utilities (debug helpers, logging, timing)
- **`flip7/cli/`** - Command-line interface

## License

TBD
